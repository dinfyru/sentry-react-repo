{"version":3,"file":"react-tether.modern.js","sources":["../src/react-tether.tsx"],"sourcesContent":["import React, { Component, isValidElement } from \"react\";\nimport type { RefObject } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Tether from \"tether\";\n\ntype TetherEvent = \"repositioned\" | \"update\";\ntype TetherEventHandler = (event?: { top: string; left: \"string\" }) => void;\n\ninterface ReactTetherProps extends Tether.ITetherOptions {\n\t// A HTML tag name. This is the element created in the DOM to contain the tethered component\n\trenderElementTag?: string;\n\n\t// Either a CSS selector to pass to document.querySelector or a DOM node\n\t// This is the location in the DOM the parent render element is created in\n\t// and the tethered component is rendered to\n\trenderElementTo?: string | HTMLElement;\n\n\t// Render prop for the element to be tethered to. This is rendered in place\n\t// of the ReactTether component\n\trenderTarget: (ref: React.RefObject<any>) => void;\n\t// Render prop for the element to be tethered. This is rendered inside the element\n\t// provided by renderElementTo or the end of the body via a React Portal.\n\t// It's wrapped in an element defined by renderElementTag\n\trenderElement?: (ref: React.RefObject<any>) => void;\n\n\t// The id prop for the renderElement defined by renderElementTag\n\tid?: string;\n\n\t// The className prop for the renderElement defined by renderElementTag\n\tclassName?: string;\n\n\t// The style prop for the renderElement defined by renderElementTag\n\tstyle?: Partial<CSSStyleDeclaration>;\n\n\t// Called on Tethers update event\n\tonUpdate?: TetherEventHandler;\n\n\t// Called on Tethers repositioned event\n\tonRepositioned?: TetherEventHandler;\n}\n\nexport default class ReactTether extends Component<ReactTetherProps> {\n\t// The DOM node of the target, obtained using ref in the render prop\n\t_targetNode: RefObject<HTMLElement> = React.createRef();\n\n\t// The DOM node of the element, obtained using ref in the render prop\n\t_elementNode: RefObject<HTMLElement> = React.createRef();\n\n\t_elementParentNode: HTMLElement | null = null;\n\n\t_tetherInstance: Tether | null = null;\n\n\toverride componentDidMount() {\n\t\tthis._createContainer();\n\t\t// The container is created after mounting\n\t\t// so we need to force an update to\n\t\t// enable tether\n\t\t// Cannot move _createContainer into the constructor\n\t\t// because of is a side effect: https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects\n\t\tthis.forceUpdate();\n\t}\n\n\toverride componentDidUpdate(previousProps: ReactTetherProps) {\n\t\t// If the container related props have changed, then update the container\n\t\tif (\n\t\t\tpreviousProps.renderElementTag !== this.props.renderElementTag ||\n\t\t\tpreviousProps.renderElementTo !== this.props.renderElementTo\n\t\t) {\n\t\t\tthis._createContainer();\n\t\t}\n\n\t\t// Verify if className props have changed\n\t\tif (\n\t\t\tthis._elementParentNode &&\n\t\t\tpreviousProps.className !== this.props.className\n\t\t) {\n\t\t\t// Add a bunch of checks against weird classNames\n\t\t\tconst previousClasses = (previousProps.className || \"\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.filter((value) => value.length > 0);\n\t\t\tconst currClasses = (this.props.className || \"\")\n\t\t\t\t.split(\" \")\n\t\t\t\t.filter((value) => value.length > 0);\n\n\t\t\tthis._elementParentNode.classList.remove(...previousClasses);\n\t\t\tthis._elementParentNode.classList.add(...currClasses);\n\t\t}\n\n\t\tthis._update();\n\t}\n\n\toverride componentWillUnmount() {\n\t\tthis._destroy();\n\t}\n\n\tgetTetherInstance() {\n\t\treturn this._tetherInstance;\n\t}\n\n\tdisable() {\n\t\tthis._tetherInstance?.disable();\n\t}\n\n\tenable() {\n\t\tthis._tetherInstance?.enable();\n\t}\n\n\ton(event: TetherEvent, handler: TetherEventHandler, ctx?: unknown) {\n\t\t// @ts-expect-error -- TS types are incomplete\n\t\tthis._tetherInstance.on(event, handler, ctx);\n\t}\n\n\tonce(event: TetherEvent, handler: TetherEventHandler, ctx?: unknown) {\n\t\t// @ts-expect-error -- TS types are incomplete\n\t\tthis._tetherInstance.once(event, handler, ctx);\n\t}\n\n\toff(event: TetherEvent, handler: TetherEventHandler) {\n\t\t// @ts-expect-error -- TS types are incomplete\n\t\tthis._tetherInstance.off(event, handler);\n\t}\n\n\tposition() {\n\t\tthis._tetherInstance?.position();\n\t}\n\n\t_runRenders() {\n\t\t// To obtain the components, we run the render functions and pass in the ref\n\t\t// Later, when the component is mounted, the ref functions will be called\n\t\t// and trigger a tether update\n\t\tlet targetComponent =\n\t\t\ttypeof this.props.renderTarget === \"function\"\n\t\t\t\t? this.props.renderTarget(this._targetNode)\n\t\t\t\t: null;\n\t\tlet elementComponent =\n\t\t\ttypeof this.props.renderElement === \"function\"\n\t\t\t\t? this.props.renderElement(this._elementNode)\n\t\t\t\t: null;\n\n\t\t// Check if what has been returned is a valid react element\n\t\tif (!isValidElement(targetComponent)) {\n\t\t\ttargetComponent = null;\n\t\t}\n\n\t\tif (!isValidElement(elementComponent)) {\n\t\t\telementComponent = null;\n\t\t}\n\n\t\treturn {\n\t\t\ttargetComponent,\n\t\t\telementComponent,\n\t\t};\n\t}\n\n\t_createTetherInstance(tetherOptions: Tether.ITetherOptions) {\n\t\tif (this._tetherInstance) {\n\t\t\tthis._destroy();\n\t\t}\n\n\t\tthis._tetherInstance = new Tether(tetherOptions);\n\t\tthis._registerEventListeners();\n\t}\n\n\t_destroyTetherInstance() {\n\t\tif (this._tetherInstance) {\n\t\t\tthis._tetherInstance.destroy();\n\t\t\tthis._tetherInstance = null;\n\t\t}\n\t}\n\n\t_registerEventListeners() {\n\t\tthis.on(\"update\", (...args) => {\n\t\t\treturn this.props.onUpdate && this.props.onUpdate.apply(this, args);\n\t\t});\n\n\t\tthis.on(\"repositioned\", (...args) => {\n\t\t\treturn (\n\t\t\t\tthis.props.onRepositioned && this.props.onRepositioned.apply(this, args)\n\t\t\t);\n\t\t});\n\t}\n\n\tget _renderNode() {\n\t\tconst { renderElementTo } = this.props;\n\t\tif (typeof renderElementTo === \"string\") {\n\t\t\treturn document.querySelector(renderElementTo);\n\t\t}\n\n\t\treturn renderElementTo || document.body;\n\t}\n\n\t_destroy() {\n\t\tthis._destroyTetherInstance();\n\t\tthis._removeContainer();\n\t}\n\n\t_createContainer() {\n\t\t// Create element node container if it hasn't been yet\n\t\tthis._removeContainer();\n\n\t\tconst { renderElementTag = \"div\", className } = this.props;\n\n\t\t// Create a node that we can stick our content Component in\n\t\tthis._elementParentNode = document.createElement(renderElementTag);\n\t\tthis._elementParentNode.className = className || \"\";\n\t}\n\n\t_addContainerToDOM() {\n\t\t// Append node to the render node\n\t\tif (\n\t\t\tthis._elementParentNode &&\n\t\t\tthis._renderNode &&\n\t\t\tthis._elementParentNode.parentNode !== this._renderNode\n\t\t) {\n\t\t\tthis._renderNode.append(this._elementParentNode);\n\t\t}\n\t}\n\n\t_removeContainer() {\n\t\tif (this._elementParentNode && this._elementParentNode.parentNode) {\n\t\t\tthis._elementParentNode.remove();\n\t\t}\n\t}\n\n\t_update() {\n\t\t// If no element component provided, bail out\n\t\tconst shouldDestroy =\n\t\t\t!this._elementNode.current || !this._targetNode.current;\n\n\t\tif (shouldDestroy) {\n\t\t\t// Destroy Tether element if it has been created\n\t\t\tthis._destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updateTether();\n\t}\n\n\t_updateTether() {\n\t\tconst {\n\t\t\t// Unused, just making sure not to pass it to tether\n\t\t\tonUpdate,\n\t\t\tonRepositioned,\n\n\t\t\trenderElement,\n\t\t\trenderElementTag,\n\t\t\trenderElementTo,\n\t\t\trenderTarget,\n\n\t\t\tclassName, // This prop is specific to this._elementParentNode\n\t\t\tid, // This prop is specific to this._elementParentNode\n\t\t\tstyle, // This prop is specific to this._elementParentNode\n\n\t\t\t// Tether options\n\t\t\t...options\n\t\t} = this.props;\n\t\tconst tetherOptions = {\n\t\t\ttarget: this._targetNode.current,\n\t\t\telement: this._elementParentNode,\n\t\t\t...options,\n\t\t};\n\n\t\tconst idString = id || \"\";\n\t\tif (this._elementParentNode && this._elementParentNode.id !== idString) {\n\t\t\tthis._elementParentNode.id = idString;\n\t\t}\n\n\t\tif (this._elementParentNode && style) {\n\t\t\tconst elementStyle = this._elementParentNode.style;\n\t\t\tfor (const key in style) {\n\t\t\t\tif (elementStyle[key] !== style[key]) {\n\t\t\t\t\tlet val = style[key];\n\t\t\t\t\tif (val) {\n\t\t\t\t\t\telementStyle[key] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._addContainerToDOM();\n\n\t\tif (this._tetherInstance) {\n\t\t\tthis._tetherInstance.setOptions(tetherOptions);\n\t\t} else {\n\t\t\tthis._createTetherInstance(tetherOptions);\n\t\t}\n\n\t\tthis._tetherInstance?.position();\n\t}\n\n\toverride render() {\n\t\tconst { targetComponent, elementComponent } = this._runRenders();\n\n\t\tif (!targetComponent) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn (\n\t\t\t<React.Fragment>\n\t\t\t\t{targetComponent}\n\t\t\t\t{elementComponent &&\n\t\t\t\t\tthis._elementParentNode &&\n\t\t\t\t\tReactDOM.createPortal(elementComponent, this._elementParentNode)}\n\t\t\t</React.Fragment>\n\t\t);\n\t}\n}\n"],"names":["ReactTether","Component","constructor","args","super","this","_targetNode","React","createRef","_elementNode","_elementParentNode","_tetherInstance","componentDidMount","_createContainer","forceUpdate","componentDidUpdate","previousProps","renderElementTag","props","renderElementTo","className","previousClasses","split","filter","value","length","currClasses","classList","remove","add","_update","componentWillUnmount","_destroy","getTetherInstance","disable","_this$_tetherInstance","enable","_this$_tetherInstance2","on","event","handler","ctx","once","off","position","_this$_tetherInstance3","_runRenders","targetComponent","renderTarget","elementComponent","renderElement","isValidElement","_createTetherInstance","tetherOptions","Tether","_registerEventListeners","_destroyTetherInstance","destroy","onUpdate","apply","onRepositioned","_renderNode","document","querySelector","body","_removeContainer","createElement","_addContainerToDOM","parentNode","append","current","_updateTether","_this$_tetherInstance4","_this$props","id","style","options","_objectWithoutPropertiesLoose","_excluded","_extends","target","element","idString","elementStyle","key","val","setOptions","render","Fragment","ReactDOM","createPortal"],"mappings":"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"}